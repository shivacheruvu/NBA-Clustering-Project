# ----------------------------------------
# pmf for freethrow example
# ----------------------------------------
pmfY <- function(y) {
return(0.25*(y==0) + 0.5*(y==1) + 0.25*(y==2))
}
yseq <- seq(from = -1, to = 3, by = 0.001)
plot(yseq, pmfY(yseq), type = "l", ylim = c(0,1),
xlab = "y", ylab = "p(y)")
# add circles at the possible values
yvals <- c(0,1,2)
points(yvals, pmfY(yvals))
# ----------------------------------------
# cdf for freethrow example
# replicate earlier realizations
set.seed(3301)
(u <- runif(n = 1))
(y <- 1 + 9*runif(n = 1))
# -------------------------------------------
# Sampling from uniform, Bernoulli, Binomial
# -------------------------------------------
set.seed(3301)
u <- runif(n = 1)
u
y <- runif(n = 1, min = 1, max = 10)
y
y <- runif(n = 1, min = 1, max = 10)
y
# replicate earlier realizations
set.seed(3301)
(u <- runif(n = 1))
(y <- 1 + 9*runif(n = 1))
# sample realizations of 100 iid RVs
y.list <- numeric(100)
for (i in 1:100) {
y.list[i] <- 1 + 9*runif(n = 1)
}
---
title: "STAT 3301 HW1"
# Define the density function
density_function <- function(x) {
if (x >= 0) {
return((2/9) * x * exp(-((x/3)^2)))
} else {
return(0)
}
}
# Create a sequence of x values from 0 to 10
x_values <- seq(0, 10, length.out = 1000)
# Calculate the corresponding density values
density_values <- sapply(x_values, density_function)
# Plot the density function
plot(x_values, density_values, type = "l", col = "blue", lwd = 2, xlab = "x", ylab = "f(x)",
main = "Density Plot of X")
# Define the density function
density_function <- function(x) {
if (x >= 0) {
return((2/9) * x * exp(-((x/3)^2)))
} else {
return(0)
}
}
# Create a sequence of x values from 0 to 10
x_values <- seq(0, 10, length.out = 1000)
# Calculate the corresponding density values
density_values <- sapply(x_values, density_function)
# Plot the density function
plot(x_values, density_values, type = "l", col = "blue", lwd = 2, xlab = "x", ylab = "f(x)",
main = "Density Plot of X")
density_function <- function(x) {
if (x >= 0) {
return((2/9) * x * exp(-((x/3)^2)))
} else {
return(0)
}
}
# Create a sequence of x values from 0 to 10
x_values <- seq(0, 10, length.out = 1000)
# Calculate the corresponding density values
density_values <- sapply(x_values, density_function)
# Plot the density function
plot(x_values, density_values, type = "l", col = "blue", lwd = 2, xlab = "x", ylab = "f(x)",
main = "Density Plot of X")
set.seed(3301)
x.list <- myrnorm(n=500, mu=68, sigma=3)
myrnorm <- function(n, mu=0, sigma=1) {
## is n odd?
odd <- (n %% 2)!=0
if (odd) {
## add 1 to n
n=n+1
}
##  perform the Box-Muller method
##  to generate n draws from N(0,1)
u1 <- runif(n/2)
u2 <- runif(n/2)
tmp <- sqrt(-2*log(u1))
z.list <- c(tmp*cos(2*pi*u2), tmp*sin(2*pi*u2))
if (odd) {
## if n was initially odd, remove an entry
z.list <- z.list[-n]
}
## transform to draw from N(mu, sigma^2)
x.list <- mu + sigma*z.list
return(x.list)
}
set.seed(3301)
x.list <- myrnorm(n=500, mu=68, sigma=3)
## compare the sample quantiles to the quantiles of N(68, 3^3)
probs <- ppoints(length(x.list))
plot(qnorm(probs, mean=68, sd=3), quantile(x.list, probs),
xlab="N(68, 3^2) percentile", ylab="Data percentile")
abline(0,1)
set.seed(3301)
theta <- 4
alpha <- 0.05
n <- 10
reps <- 10000
simulate_coverage_probability <- function() {
y.list <- 1 + (theta - 1) * runif(n)
M <- max(y.list)
lower_bound <- M
upper_bound <- M / (alpha^(1/n))
coverage <- (theta >= lower_bound) && (theta <= upper_bound)
return(coverage)
}
coverage_probabilities <- replicate(reps, simulate_coverage_probability())
estimated_coverage_probability <- mean(coverage_probabilities)
print( estimated_coverage_probability)
lambda_true <- 1.25
alpha <- 0.05
n <- 100
reps <- 10000
coverage <- 0
for(i in 1:reps){
y_values <- rrv(n, 5/4)
y_min <- min(y_values)
lambda_hat <- -n / (sum(log(y_values)) - n * log(y_min))
se <- (qnorm(1 - alpha/2)*(lambda_hat + 1)/sqrt(n))
lower_bound <- lambda_hat - se
upper_bound <- lambda_hat + se
if(lower_bound <= lambda_true && lambda_true <= upper_bound){
coverage <- coverage + 1
}
}
set.seed(3301)
lambda_true <- 1.25
alpha <- 0.05
n <- 100
reps <- 10000
coverage <- 0
for(i in 1:reps){
y_values <- rrv(n, 5/4)
y_min <- min(y_values)
lambda_hat <- -n / (sum(log(y_values)) - n * log(y_min))
se <- (qnorm(1 - alpha/2)*(lambda_hat + 1)/sqrt(n))
lower_bound <- lambda_hat - se
upper_bound <- lambda_hat + se
if(lower_bound <= lambda_true && lambda_true <= upper_bound){
coverage <- coverage + 1
}
}
set.seed(3301)
lambda_true <- 1.25
alpha <- 0.05
n <- 100
reps <- 10000
coverage <- 0
for(i in 1:reps){
y_values <- rrv(n, 5/4)
y_min <- min(y_values)
lambda_hat <- -n / (sum(log(y_values)) - n * log(y_min))
se <- (qnorm(1 - alpha/2)*(lambda_hat + 1)/sqrt(n))
lower_bound <- lambda_hat - se
upper_bound <- lambda_hat + se
if(lower_bound <= lambda_true && lambda_true <= upper_bound){
coverage <- coverage + 1
}
```{r}
set.seed(3301)
lambda_true <- 1.25
alpha <- 0.05
n <- 100
reps <- 10000
coverage <- 0
for(i in 1:reps){
y_values <- rrv(n, 5/4)
y_min <- min(y_values)
lambda_hat <- -n / (sum(log(y_values)) - n * log(y_min))
se <- (qnorm(1 - alpha/2)*(lambda_hat + 1)/sqrt(n))
lower_bound <- lambda_hat - se
upper_bound <- lambda_hat + se
if(lower_bound <= lambda_true && lambda_true <= upper_bound){
coverage <- coverage + 1
}
}
set.seed(3301)
lambda_true <- 1.25
alpha <- 0.05
n <- 100
reps <- 10000
coverage <- 0
for(i in 1:reps){
y_values <- rrv(n, 5/4)
y_min <- min(y_values)
lambda_hat <- -n / (sum(log(y_values)) - n * log(y_min))
se <- (qnorm(1 - alpha/2)*(lambda_hat + 1)/sqrt(n))
lower_bound <- lambda_hat - se
upper_bound <- lambda_hat + se
if(lower_bound <= lambda_true && lambda_true <= upper_bound){
coverage <- coverage + 1
}
}
hw2_dat <- readRDS("~/Desktop/HW/Year3Term1/STAT3301/hw2_dat.RDS")
View(hw2_dat)
player_data_processed <- game_data %>%
filter(Tm != "TOT") %>%
filter(G > 20) %>%
select(-Player.additional) %>%
mutate(X3P. = ifelse(X3PA == 0, 0, X3P.),
FT. = ifelse(FTA == 0, mean(FT., na.rm = TRUE), FT.)) %>%
mutate_at(vars(FG:PTS), funs(./MP))
